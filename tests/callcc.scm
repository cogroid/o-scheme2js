(define (t1)
   (let ((tt #f)
	 (YY #t))
      (print "XXX")
      (if YY
	  (begin
	     (set! YY #f)
	     (if (call/cc (lambda (k)
			     (print "in call/cc")
			     (set! tt k)
			     #t))
		 (begin
		    (print "first")
		    (tt #f))
		 (print "second")))
	  (print "BAD BAD"))))
(print "t1")
(t1)

(define (t2)
   (let ((tt #f)
	 (YY #t))
      (print "XXX")
      (case YY
	 ((#t)
	  (set! YY #f)
	  (if (call/cc (lambda (k)
			  (print "in call/cc")
			  (set! tt k)
			  #t))
	      (begin
		 (print "first")
		 (tt #f))
	      (print "second")))
	 (else
	  (print "BAD BAD")))))
(print "t2")
(t2)
   

(define (t3)
   (define c1 0)
   (define k #f)
   
   (call/cc (lambda (kk)
	       (set! k kk)))
   (print c1)
   (set! c1 (+ c1 1))
   (if (< c1 5)
       (k)))
(print "t3")
(t3)
   
(define (t4)
   (define *funs* '())
   (define *count* 0)
   (define *done* #f)
   
   (define (g)
      (f)
      (print "rest of g"))
   
   (define (f)
      (let loop ((i 0))
	 (if (< i 10)
	     (begin
		(call/cc
		 (lambda (k)
		    (set! *funs* (cons (lambda () (print i) (k)) *funs*))))
		(loop (+ i 1)))))
      (print "rest of f"))
   
   (g)

   (set! *count* (+ *count* 1))
   (if (< *count* 5)
       ((car *funs*))))
(print "t4")
(t4)

(define (t4_5)
   (define *tt* #f)
   (define *bool* #f)
   
   (define (h)
      (call/cc (lambda (k)
		  (set! *tt* (lambda () (print "x") (k #unspecified))))))
   (h)
   (set! *bool* (not *bool*))
   (if *bool* (*tt*))
   (set! h #f))
(print "t4_5")
(t4_5)
   
(define (t5)
   (define (gg)
      (map (lambda (x)
	      (hh x))
	   '(1 2 3 4 5)))
   
   (define (hh x)
      (let ((outer-k #f))
	 (if (call/cc (lambda (k)
			 (set! outer-k k)
			 #t))
	     (begin
		(print "1 " x)
		(outer-k #f))
	     (print "2 " x))))
   
   (gg)
   (set! hh #f)
   (set! gg #f))
(print "t5")
(t5)

(define (t6)
   (define (ggg)
      (map print
	   '(1 2 3 4 5)))
   
   (ggg)
   (set! ggg #f))
(print "t6")
(t6)
   
(define (t7)
   (define *k_* #f)
   (define *g_* #f)
   
   (define (f_ h)
      (h)
      (set! *g_* (call/cc (lambda (k)
			     (set! *k_* k)
			     #t)))
      (print "after g_"))

   (define (g_)
      (let ((m f_))
	 (m (lambda () (set! m (lambda () (print "failed")))))))
   
   (g_)

   (if *g_* (*k_* #f)))
(print "t7")
(t7)
(print "done")
	    
(define (t8)
   (define (f1)
      (apply print '("1" "2" "3")))
   (define (f2)
      (let ((g map))
	 (print (g (lambda (x) (+ x 1)) '(1 2 3 4)))))
   (define (f3)
      (let ((g for-each)
	    (h (lambda (x) (print x))))
	 (g h '(1 2 3))))
   (define (f4)
      (call-with-values (lambda () 5)
			(lambda L (print L))))
   (define (f5)
      (dynamic-wind (lambda () (print 'before))
		    (lambda () (print 'body))
		    (lambda () (print 'after))))
;   (define (f6)
;      (let* ((g (lambda () #unspecified))
;	     (o (new g)))
;	 (js-field-set! o 'field 'o-field)
;	 (js-call o (lambda () (print (js-field this 'field))))))
   (define (f7)
      (let ((ht (make-hashtable)))
	 (for-each (lambda (x)
		      (hashtable-put! ht x #t))
		   '(1 2 3 4))
	 (hashtable-for-each ht
			     (lambda (key val)
				(print key val)))))
   (print "f1") (f1)
   (print "f2") (f2)
   (print "f3") (f3)
   (print "f4") (f4) ;; TODO: fix call-with-values;
   (print "f5") (f5)
;   (print "f6") (f6)
;   (print "f7") (f7)
   )
(print "t8")
(t8)

(define (t9)
   (define (some-fun)
      'do-nothing)
   
   (define (f1)
      (apply (lambda L
		(print L)
		(some-fun))
	     '("1" "2" "3")))
   (define (f2)
      (let ((g map))
	 (print (g (lambda (x) (some-fun) (+ x 1)) '(1 2 3 4)))))
   (define (f3)
      (let ((g for-each)
	    (h (lambda (x) (some-fun) (print x))))
	 (g h '(1 2 3))))
   (define (f4)
      (call-with-values (lambda () (some-fun) 5)
			(lambda L (print L))))
   (define (f4b)
      (call-with-values (lambda () 5)
			(lambda L (some-fun) (print L))))
   (define (f5)
      (dynamic-wind (lambda () (some-fun) (print 'before))
		    (lambda () (print 'body))
		    (lambda () (print 'after))))
   (define (f5b)
      (dynamic-wind (lambda () (print 'before))
		    (lambda () (some-fun) (print 'body))
		    (lambda () (print 'after))))
;   (define (f6)
;      (let* ((g (lambda () #unspecified))
;	     (o (new g)))
;	 (js-field-set! o 'field 'o-field)
;	 (js-call o (lambda () (some-fun) (print (js-field this 'field))))))
   (define (f7)
      (let ((ht (make-hashtable)))
	 (for-each (lambda (x)
		      (hashtable-put! ht x #t))
		   '(1 2 3 4))
	 (hashtable-for-each ht
			     (lambda (key val)
				(some-fun)
				(print key val)))))
   (f1)
   (f2)
   (f3)
   (f4)
   (f4b)
   (f5)
   (f5b)
;   (f6)
;   (f7)
   (set! some-fun #f))
(print "t9")
(t9)
